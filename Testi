<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FPS Game</title>
  <script defer src="https://cdn.babylonjs.com/babylon.js"></script>
  <script defer src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script defer src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
  <canvas id="renderCanvas" style="width: 100%; height: 100%;"></canvas>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      var canvas = document.getElementById('renderCanvas');
      var engine = new BABYLON.Engine(canvas, true);
      var camera;

      var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

        var ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 100, height: 100 }, scene);
        ground.material = new BABYLON.StandardMaterial('groundMaterial', scene);
        ground.material.diffuseColor = new BABYLON.Color3(0.5, 0.4, 0.1);

        camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 1, -10), scene);
        camera.setTarget(new BABYLON.Vector3(0, 1, 0));
        camera.attachControl(canvas, true);

        createTrees(scene);

        return scene;
      };

      var createTrees = function (scene) {
        for (var i = 0; i < 100; i++) {
          var tree = BABYLON.MeshBuilder.CreateCylinder('tree', { height: 3, diameterTop: 0.5, diameterBottom: 2 }, scene);
          tree.position = new BABYLON.Vector3(Math.random() * 90 - 45, 1.5, Math.random() * 90 - 45);
          tree.material = new BABYLON.StandardMaterial('treeMaterial', scene);
          tree.material.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.4);
          tree.material.specularColor = new BABYLON.Color3(0, 0, 0);
          tree.material.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
          tree.physicsImpostor = new BABYLON.PhysicsImpostor(tree, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: 0, restitution: 0, ignoreParent: true }, scene);
        }
      };

      var scene = createScene();

      engine.runRenderLoop(function () {
        scene.render();
      });

      scene.inputStates = { up: false, down: false, left: false, right: false, jump: false };

      window.addEventListener('keydown', function (event) {
        switch (event.key) {
          case 'w':
            scene.inputStates.up = true;
            break;
          case 's':
            scene.inputStates.down = true;
            break;
          case 'a':
            scene.inputStates.left = true;
            break;
          case 'd':
            scene.inputStates.right = true;
            break;
          case ' ':
            scene.inputStates.jump = true;
            break;
        }
      });

      window.addEventListener('keyup', function (event) {
        switch (event.key) {
          case 'w':
            scene.inputStates.up = false;
            break;
          case 's':
            scene.inputStates.down = false;
            break;
          case 'a':
            scene.inputStates.left = false;
            break;
          case 'd':
            scene.inputStates.right = false;
            break;
          case ' ':
            scene.inputStates.jump = false;
            break;
        }
      });

      canvas.addEventListener('touchstart', function (event) {
        // Käsittele kosketuksen alkamista tarvittaessa
      });

      canvas.addEventListener('touchmove', function (event) {
        // Käsittele kosketuksen liikettä tarvittaessa
      });

      canvas.addEventListener('touchend', function (event) {
        // Käsittele kosketuksen loppumista tarvittaessa
      });

      scene.onBeforeRenderObservable.add(function () {
        var playerSpeed = 0.1;
        var playerDirection = new BABYLON.Vector3(0, 0, 0);

        if (scene.inputStates.up) {
          playerDirection.z = 1;
        }
        if (scene.inputStates.down) {
          playerDirection.z = -1;
        }
        if (scene.inputStates.left) {
          playerDirection.x = -1;
        }
        if (scene.inputStates.right) {
          playerDirection.x = 1;
        }
        if (scene.inputStates.jump) {
          // Käsittele hyppy tarvittaessa
        }

        playerDirection.normalize();

        var delta = playerDirection.scale(playerSpeed);
        var forward = camera.get
